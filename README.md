# Двоичные деревья

Библиотека двоичных деревьев: двоичное дерево поиска, AVL-дерево, красно-чёрное дерево. Деревья позволяют хранить пары
ключ-значение и поддерживают операции поиска вершины, вставки и удаления, а также возможность итерирования по ключам и
значениям. Ключи и значения являются величинами некоторых обобщенных типов, при этом важно уметь сравнивать ключи.

### Инстанцирование дерева

Двоичное дерево поиска может быть создано с помощью следующих фабричных методов:

* `BinarySearchTree.of<K, V>(balancer, comparator)`  
  Создаёт новое пустое двоичное дерево поиска с ключами типа `K` и значениями типа `V`, балансируемое балансировщиком
  `balancer` и упорядоченное компаратором `comparator`.  
  Пример:
   ```kotlin
   val reversedAVLTree = BinarySearchTree.of<Int, String>(AVLTreeBalancer, reverseOrder())
   ```

* `BinarySearchTree.of<K, V>(balancer)`  
  Создаёт новое пустое двоичное дерево поиска с ключами типа `K` и значениями типа `V`, балансируемое балансировщиком
  `balancer` и упорядоченное естественным порядком ключей.  
  Данный фабричный метод может быть вызван, только если `K` реализует интерфейс `Comparable<K>`.  
  Пример:
   ```kotlin
   val redBlackTree = BinarySearchTree.of<Int, String>(RedBlackTreeBalancer)
   ```

### Предоставляемые библиотекой балансировщики

| Балансировщик          | Описание                                            | Сложность операций поиска, вставки и удаления в худшем случае |
| ---------------------- | --------------------------------------------------- | ------------------------------------------------------------- |
| `NoopTreeBalancer`     | Балансировка дерева не производится                 | *O(n)*                                                        |
| `AVLTreeBalancer`      | Поддерживаются все инварианты AVL-дерева            | *O(log n)*                                                    |
| `RedBlackTreeBalancer` | Поддерживаются все инварианты красно-чёрного дерева | *O(log n)*                                                    |

### Использование

Двоичное дерево поиска (`BinarySearchTree`) реализует интерфейс
[MutableMap](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-map/).

Примеры:

| Пример                 | Описание                                                                                                    |
| ---------------------- | ----------------------------------------------------------------------------------------------------------- |
| `bst[key] = value`     | Сопоставляет ключу `key` значение `value`                                                                   |
| `bst.containsKey(key)` | Возвращает `true`, если ключу `key` сопоставлено какое-либо значение, в противном случае возвращает `false` |
| `bst[key]`             | Возвращает значение, сопоставленное ключу `key` или `null` в случае отсутствия такового                     |
| `bst.remove(key)`      | Удаляет сопоставление для ключа `key`                                                                       |
| `bst.сlear()`          | Удаляет все сопоставления из дерева                                                                         |
| `bst.entries`          | Возвращает самообновляющееся множество хранящихся в дереве пар ключ-значение                                |
| `bst.keys`             | Возвращает самообновляющееся множество хранящихся в дереве ключей                                           |
| `bst.values`           | Возвращает самообновляющуюся коллекцию хранящихся в дереве значений                                         |

### Особенности реализации

Два ключа полагаются равными тогда и только тогда, когда результатом их сравнения является `0`.

Гарантируется, что итерация по ключам, значениям и записям двоичного дерева поиска производится в порядке следования
соответствующих им ключей в дереве, заданным используемым для создания дерева компаратором или естественным порядком
ключей, если компаратор не был передан при создании дерева.

Структурная модификация - это любая операция, добавляющая или удаляющая сопоставления. Структурной модификацией не
является изменение значения, сопоставленного ключу, уже присутствующему в двоичном дереве поиска.

Данная реализация не производит синхронизацию, поэтому если несколько потоков используют двоичное дерево поиска
одновременно и по крайней мере один из них производит структурные модификации, то внешняя синхронизация необходима.

При вызове `bst.entries.iterator()`, `bst.keys.iterator()` и `bst.values.iterator()` возвращаются *fail-fast* итераторы:
если двоичное дерево поиска структурно модифицируется после создания итератора не при помощи метода `remove` самого
итератора, то при следующем вызове любого метода итератора будет выброшено `ConcurrentModificationException`.

Данное *fail-fast* поведение итераторов не гарантируется при произведении структурных модификаций из другого
несинхронизированного потока.

Все получаемые из данной реализации `MutableEntry` могут использоваться и остаются актуальными вплоть до удаления
соответствующего им ключа из двоичного дерева поиска. Поведение `MutableEntry` при его использовании после удаления
соответствующего ему ключа не определено.

### Система сборки

Для управления проектом используется система сборки [Gradle](https://gradle.org/).

Файлы с исходным кодом должны лежать в директории `src/main/kotlin` \
Файлы с тестами должны лежать в директории `src/test/kotlin`

Сборка кода без запуска тестов осуществляется командой

```bash
./gradlew assemble
```

Сборка кода и запуск тестов осуществляется командой
```bash
./gradlew test
```

### Тестирование
Для тестирования используется библиотека [JUnit 5](https://junit.org/junit5/).
Поэтому тесты для деревьев нужно писать с использованием этой библиотеки.

После прохождения тестирования с помощью библиотеки [JaCoCo](https://www.eclemma.org/jacoco/) генерируется отчёт о покрытии кода тестами.
Отчёты о тестировании можно найти в директории `${buildDir}/reports`.

### CI
В репозитории определены 2 сценария для GitHub Actions.
- On push: \
  Вызывается сборка кода без запуска тестов.
- On pull request: \
  Вызывается сборка кода и тестирование. После прохождения тестов генерируется отчёт о покрытии кода тестами.
  Краткая информация о покрытии печатается, а полноценный отчёт о тестировании и покрытии публикуется как артефакт
  (доступен для скачивания в разделе Summary выполняемого Action'а).

### Рull request'ы
При этом код появляется в основной ветке посредством PR'ов. \
На Рull request'ы накладываются следующие ограничения (проверяются автоматически):
- Описание PR'a не должно быть пустым;
- PR проходит ревью хотя бы одного члена команды перед выполнением слияния.
